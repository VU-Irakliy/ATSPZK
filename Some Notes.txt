Some Notes on how to use the tree library


Node() a tree node that has to have a name
AnyNode() tree node with no name
Node(name, parent = , weight = )
.weight - shows the weight of the B node if reached from A node
.children - we see the nodes children in a form of a tuple 

Assignment Problem:
Worst case scenario for formed subtoures: If N is even -> n/2 and if N is odd -> n/2 - 0.5



DEF ASSIGNMENT Problem



Tuple [()]
points - not touch
named_points = [('A', [0, 8, 8, 2, 4]), ('B', [4, 0, 1, 7, 4]), ('C', [3, 9, 0, 8, 5]), ('D', [5, 1, 7, 0, 9]), ('E', [6, 1, 1, 3, 0])]
matrix_points = [([0, 8, 8, 2, 4]), ([4, 0, 1, 7, 4]), ([3, 9, 0, 8, 5]), ( [5, 1, 7, 0, 9]), ([6, 1, 1, 3, 0])]



ASSIGNMENT(R,E,C)


    """
    resulting_complete tours = [] (DFBnB)
    min_result = 0 (BFS)

    if complete:
        BFS:
        min_result = ass_result[1]
        return

        
    if not complete:
        we pick the subtour
        IF include > 0:
            we substract the number of edges to eliminate from that subtour
            check all tours
        which one has minimum number of edges to elminate:
            our_pick = []
            if len(resulting_subtours) == 1: for formality
                our_pick = resulting_subtours[0]
            else:
                pick resulting_subtours[0]
            cand = dissolve the subtour into edges
            create children
            generate their names/variables
            add each one of them 1 unique edge from cand and from their parent's exclude to child's exclude
            add your resulting include to them


            
            
        tours
    """

  
    """
    include = []
    exclude = []
    cand = []
    A1 = Node("A1", weight = assignment_hungarian(named_matrix, names, matrix, include, exclude, cand)[1])
    A/B/D/C

    A2 = Node("A2", parent = A1, weight = assignment_hungarian(named_matrix, names, matrix, include, exclude, cand)[1])
    """
